/*
 * Led Modular progamming using structures
 */

/*
 * 1. Why typedef is used here?

Your struct defines the memory layout of the GPIO peripheral registers.
For example:

typedef struct {
    __vo uint32_t MODER;
    __vo uint32_t OTYPER;
    ...
} GPIO_TypeDef;


typedef gives the struct a simpler alias name (GPIO_TypeDef) so that you can declare variables or pointers of this type without having to repeat struct ... every time.

✅ With typedef:

GPIO_TypeDef *pGPIOA = (GPIO_TypeDef *)0x40020000; // Base address of GPIOA


❌ Without typedef:

struct GPIO_TypeDef {
    __vo uint32_t MODER;
    __vo uint32_t OTYPER;
    ...
};

struct GPIO_TypeDef *pGPIOA = (struct GPIO_TypeDef *)0x40020000;
 *
 */

#include <stdint.h>

#define __vo volatile

#define PERIPH_BASE_ADDR			(0x40000000UL)
#define AHB1_PERIPH_OFFSET			(0x00020000UL)
#define AHB1_BASE_ADDR				(PERIPH_BASE_ADDR + AHB1_PERIPH_OFFSET)

#define GPIOA_OFFSET				(0x0000UL) // 0x00000000 Both are same (Be good at ! Number Systems !)
#define GPIOA_BASE_ADDR 			(AHB1_BASE_ADDR + GPIOA_OFFSET)

#define RCC_OFFSET					(0x3800UL)
#define RCC_BASE_ADDR				(AHB1_BASE_ADDR + RCC_OFFSET)

#define RCC_AHB1ENR_OFFSET			(0x30UL)
#define RCC_AHB1ENR_ADDR			(*(volatile unsigned int * ) (RCC_BASE_ADDR + RCC_AHB1ENR_OFFSET))

#define GPIOA_MODER_OFFSET 			(0x00UL)
#define GPIOA_MODER_ADDR			(*(volatile unsigned int * ) (GPIOA_BASE_ADDR + GPIOA_MODER_OFFSET))

#define GPIOA_ODR_OFFSET			(0x14UL)
#define GPIOA_ODR_ADDR 				(*(volatile unsigned int * ) (GPIOA_BASE_ADDR + GPIOA_ODR_OFFSET))

#define GPIOAEN						(1U << 0)

#define PIN5						(1U << 5)
#define LED_PIN						 PIN5

typedef struct{
		/*     __vo stands for volatile keyword which is defined in the macro of this header file*/

		// Each register located inside the GIPO are in the offsets of 4 bytes (32 bits)

		// In this structure we are only using the MODER and the ODR register of the GPIOA so we are going to make the structure for this puspose alone not all the registers
		// The Order of the registers must be followed to maintain the offset values of the register .. that is why we are adding some dummy space as an array ..
		// There are 4 registers are between the Moder and the ODR Register .. so adding 4 dummy values using and array
		// So that the struct will add 4 bytes to each of them to get the correct respective value of the ODR Register

		__vo uint32_t MODER;			/* GPIO port mode register,			*/
		__vo uint32_t DUMMY[4];     /* Dummy register to maintain the offsed values */
		__vo uint32_t ODR;			/* GPIO port output data register,	*/
		// We dont nee anything after the ODR Register(For this Program ) that is why nothing is initialized
}GPIO_TypeDef;

typedef struct
{
	__vo uint32_t DUMMY[12];
    __vo uint32_t AHB1ENR;      /* RCC AHB1 peripheral clock enable register,                   Address offset: 0x30    */

}RCC_TypeDef;

#define RCC						((RCC_TypeDef *)  RCC_BASE_ADDR)
#define GPIOA 					((GPIO_TypeDef *) GPIOA_BASE_ADDR)





int main(void){
	/*
	 * 1. Enable clock to GPIOA
	 * 2. set PA5 as output pin
	 * 3. set the PA5 HIGH
	 */

	// 1. Enable clock to GPIOA
	//RCC_AHB1ENR_ADDR |= GPIOAEN;
	RCC->AHB1ENR |= GPIOAEN;

	// 2. set PA5 as output pin
//	GPIOA_MODER_ADDR |=  (1U << 10); // Set Bit 10 to High
//	GPIOA_MODER_ADDR &= ~(1U << 11); // Set Bit 11 to Low
	GPIOA->MODER |=  (1U << 10);
	GPIOA->MODER &= ~(1U << 11);


	while(1){
		// Led Toggle using Xor Operation
		//GPIOA_ODR_ADDR ^= LED_PIN;
		GPIOA->ODR ^= LED_PIN;

		for(long i=0; i<1000; i++){
			// Delay loop
		}
	}


}










