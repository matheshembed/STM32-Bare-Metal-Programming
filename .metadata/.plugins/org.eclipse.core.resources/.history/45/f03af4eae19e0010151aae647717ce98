#include "adc.h"
#include <stdint.h>

#define GPIOAEN					(1U << 0) //RCC_AHB1ENR
#define ADC1EN					(1U << 8) //RCC_APB2ENR
#define ADC_CH1					(1U << 0) //For ADC_SQR3 register
#define ADC_SEQ_LEN				 0x00     //For the Number of sequence (channels)
#define ADC_ON_CR2				(1U << 0) //To Enable ADC (ADON) BIT  in the ADC_CR2 Register
#define CR2_SWSTART				(1U << 30)//To start the conversion
#define SR_EOC					(1U << 1) //End of conversion Flag in the ADC_SR Register
#define CR2_CONT				(1U << 1) //To initialize the Continuous conversion mode present inside the ADC_CR2 Reg

/*
ADC

Analog => refers to continuous (Acquisition of data)

8  bit -> 256  (2^8)
10 bit -> 1024
12 bit -> 4096
16 bit -> 65536

ADC Independent Modes
There are other modes  such as Dual Mode which involves having two ADC Modules.

1. Single channel , single conversion mode

2. multichannel(scan), single conversion mode

3. single channel continuous conversion mode

4. multichannel continuous conversion mode

5. injected continuous conversion mode

STM32F4 -> Has single ADC Modules
STM32F7 -> Two ADC Modules


1 . Single channel , single conversion mode
Simplest ADC Mode
ADC Performs a single conversion of a single channel x and stops after conversion is complete
EG: Measurement of voltage level to determine if a system should be started or not

2 . multichannel(scan), single conversion mode
Used to convert multiple channels successively
Up to 16 different channels with different sampling times can be converted on the stm32 14 (which means we can convert 16 sensors)
EG: Measurement of multiple sensors to determine whether a system should start or not

3 . single channel continuous conversion mode
Used to convert a single channel continuously
Works in the background without intervention from the CPU
EG: Measurement of room temperature continuous to adjust air-conditioner

4 . multichannel continuous conversion mode
Used to convert multiple channels continuously
Up to 16 different channels with different sampling times can be converted on the stm32f4
EG: Continuously measuring multiple accelerometers to adjust joints of a robotic arm

5 . injected continuous conversion mode
Intended fo use when Conversion is triggered by an external event or by software
The injected group has priority over the regular channel group
interrupts the conversion of the current channel in the regular channel group
EG: For synchronising the conversion of channels to an event




*/

/*
 * PA1 IS INITIALIZED BECAUSE THE ADC1_IN1 (IN1 => INPUT CHANNEL)
 * Refer Table 10 at pg 46 in the data sheet
 */

void Pa1_Adc_Interrupt_Init(void)
{
	/******************Configure the ADC GPIO PIN ****************************/

	/*Enable Clock access to ADC Pin's Port (To GPIOA) */
	RCC->AHB1ENR |= GPIOAEN;
	/*Set the mode of PA1 to analog mode */
	GPIOA->MODER |= (1U << 2);
	GPIOA->MODER |= (1U << 3);

	/*Configure the ADC Module*/
	/*Enable Clock access to ADC*/
	RCC->APB2ENR |= ADC1EN;

	/***********************Configure ADC Parameters*****************************/
	ADC1->SQR3 = ADC_CH1; // We want to set this only not any other values so assigning it instead or doing OR Operations (That will also work)


	ADC1->SQR1 =  ADC_SEQ_LEN;

	/*Enable the ADC Module*/
	/*To enable we have to configure the ADC_CR2 register*/
	ADC1->CR2 |= ADC_ON_CR2;

}


void Pa1_Adc_Init(void)
{
	/******************Configure the ADC GPIO PIN ****************************/

	/*Enable Clock access to ADC Pin's Port (To GPIOA) */
	RCC->AHB1ENR |= GPIOAEN;
	/*Set the mode of PA1 to analog mode */
	GPIOA->MODER |= (1U << 2);
	GPIOA->MODER |= (1U << 3);

	/*Configure the ADC Module*/
	/*Enable Clock access to ADC*/
	RCC->APB2ENR |= ADC1EN;

	/***********************Configure ADC Parameters*****************************/

	/*Conversion Sequence start*/

	/* EG : ADC Configured with 3 channels
	 *  ch2, ch3, ch5
	 *  first = ch5;
	 *  second = ch2;
	 *  third = ch3;
	 *  If we want the ch5 to be activated first then we have to give the binary value of the channel (5) to the ADC_SQR register in the value of SQ1
	 *  Then to activate the ch2 at second write binary value of the channel (2) to the ADC_SQR register in the value of SQ2
	 */

	ADC1->SQR3 = ADC_CH1; // We want to set this only not any other values so assigning it instead or doing OR Operations (That will also work)

	/*Conversion sequence length*/
	/*Number of channel is the sequence length */
	/*To configure this we have to write the binary value to the register ADC_SQR1 from the bit 20-23 (L)*/
	/* 0000 => For 1 Conversion */
	/* We dont need the other stuffs in this register so we write 0 to the entire register if we want to configure lets say (SQR13) we will do the OR Operation*/
	ADC1->SQR1 =  ADC_SEQ_LEN;

	/*Enable the ADC Module*/
	/*To enable we have to configure the ADC_CR2 register*/
	ADC1->CR2 |= ADC_ON_CR2;

}



void Start_Conversion_Conti(void)
{
	/*Enable Continuous conversion*/
	ADC1->CR2 |= CR2_CONT;

	/*Start the ADC Conversion*/
	/*Configure the ADC_CR2 register in the bit fields of SWSTART(SOFTWARRE START) Bit 30 */
	/*Which start conversion with software trigger Because we can trigger the conversion with the timer as well */
	ADC1->CR2 |= CR2_SWSTART; // Starts Conversion of regular channels

}

uint32_t Adc_Read(void)
{
	/*Wait for the conversion to complete */
	/*A flag will be raised when the  conversion is completed */
	/*ADC_SR REGISTER Bit Position ECO(End of conversion)*/
	/*
	 *  Bit 1 EOC: Regular channel end of conversion
	 *  This bit is set by hardware at the end of the conversion of a regular group of channels.
	 *  It is cleared by software or by reading the ADC_DR register.
	 *  0: Conversion not complete (EOCS = 1), or sequence of conversions not complete (EOCS = 0)
	 *  1: Conversion complete (EOCS = 1), or sequence of conversions complete (EOCS = 0)
	 */

	/*Wait for the data to be converted*/
	while(!(ADC1->SR & SR_EOC)){}

	/*Read converted result*/
	return ADC1->DR;

}
































