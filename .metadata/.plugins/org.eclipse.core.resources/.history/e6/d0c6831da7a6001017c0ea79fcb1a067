// Serial Communication

/*

Parallel communication -> Transferring all the bit simultaneously(Multiple wire)-> Equal to the number of bit that is going to be transferred is equal to the no.of wires

Serial Communication  -> 1 Bit at a time (single wire)



Complexity less for serial and less cost

Complexity High for Parallel and high cost



Data transfer speed -> Slow (serial)

Data transfer speed -> High (parallel)


Distance -> Long distance capable (serial)

Distance -> Short distance only  (parallel)


Synchronization -> Serial comm requires proper synchronization between transmitter and receiver to ensure the data is correctly interpretation

Synchronization -> It is easier for parallel communication


Serial applications

	This is applied where simplicity, cost effectiveness, long distance
	such as SERIALL PORTS , RS232 , USB and so on

Parallel applications

	Not common -- used in very very specific applications not in general purpose



Serial Communication

Synchronous -> Data and Clock signal is transmitted

Asynchronous -> Clock is not transmitted
	     -> Both transmitter and receiver aggree upon a predefined clock known as baud rate

We have UART AND USART


Different Transmission modes

Simplex -> transmitter to receiver only
Half Duplex -> Transmitter receiver <-> transmitter receiver (eg wakie takie_) has only one channel (lets say wire -- only one)
Full Duplex ->  Transmitter -> receiver
		Receiver  <- Transmitter
		(transmit and receive simultaneously)

*/



#include "stm32f4xx.h"
#include <stdint.h>

#define GPIOAEN					(1U << 0)
#define UART2EN					(1U << 17)
#define USART2_CR1				(1U << 3)
#define UART_EN					(1U << 13)
#define UART_SR_TXE				(1U << 7)

#define SYS_FREQ				16000000 // MCU CLOCK SPEED
#define APB1_CLK				SYS_FREQ

#define UART_BAUDRATE			112500

static void Uart_Set_Bd(USART_TypeDef *USARTx, uint32_t PeriClk, uint32_t BaudRate);
static uint16_t Compute_Uart_Bd(uint32_t PeriClk, uint32_t BaudrRate);
void UART2TX_Init(void);
void Uart2_Write(char ch);


int main(void){

	UART2TX_Init();


	while(1){

		Uart2_Write('M');

	}
}

void UART2TX_Init(void){
	// The UART2 IS CONNECTED TO THE GPIOA AND PIN 2
	// To initialize the uart we have to make the gpio as the alternate function which is



	// Clock access to the GPIOA
	RCC->AHB1ENR |=  GPIOAEN ;

	// Setting PA2 to alternate function mode
	GPIOA->MODER |=  (1U << 5); //1
	GPIOA->MODER &= ~((1U << 4));//0

	// Set PA2 to alternate function tyoe to UART_TX (AF7)
	// AFRL REGISTER DUE THE USART IS CONNECTED TO THE GPIO PIN 2
	GPIOA->AFR[0] &= (~(1U << 11));
	GPIOA->AFR[0] |= (1U << 10);
	GPIOA->AFR[0] |= (1U << 9);
	GPIOA->AFR[0] |= (1U << 8);

	// Enable the Clock access to the UART 2
	RCC->APB1ENR |=  UART2EN ;

	// Configure the Baud rate
	Uart_Set_Bd(USART2, APB1_CLK, UART_BAUDRATE);

	// Configure the transfer direction
	// I want to clear every bits of the register and set only the 3 pin that is why we are not usig the OR operator
	USART2->CR1 |= USART2_CR1;
	//Since we are already written the value in the CR1 Register ourself we dont want it to be vanished .. we need that ... so using the OR Operator as usual.
	USART2->CR1 |= UART_EN;
}

void Uart2_Write(char ch){
	// Make sure the transmit data register is empty before writing the data to it
	// Then Write to transmit data register

	// 0 => Data is not transferred to the shift register
	// 1 =>  Data is transferred to the shift register
	while(!(USART2->SR & UART_SR_TXE));

	// Write to the Transmit data register
	USART2->DR =  (ch & 0xFF);
}
static void Uart_Set_Bd(USART_TypeDef *USARTx, uint32_t PeriClk, uint32_t BaudRate){

	USARTx->BRR = Compute_Uart_Bd(PeriClk,BaudRate);
}

static uint16_t Compute_Uart_Bd(uint32_t PeriClk, uint32_t BaudRate){

	return ((PeriClk + (BaudRate/2U))/BaudRate);
}


